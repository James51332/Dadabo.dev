---
layout: post
title: Revisiting My Ocean Simulation
---

It's been a fair bit of time since my first attempt at simulation the ocean through a sum of sines approach. Now, I'm ready to tackle a more daunting, but much more appealling approach using the Fourier transform!

<!--more-->

### Where We Left Off

This is the third post relevant to our journey to simulate ocean water. The [first post](https://dadabo.dev/2024/03/31/waves.html) discusses the process of transforming a flat plane into a surface that vaguely resembles water by adding waves of various directions, frequencies, and amplitudes together to offset its vertices. The [second post](https://dadabo.dev/2024/04/11/fourier.html) discusses the Fourier transform, and is an intuitive introduction to the method we will use to enhance our ocean!

Right now, our understanding of the Fourier transform is that it is a convenient way to convert between a signal's *time domain* and its *frequency domain* (also known as its *spectrum*). We can also take the inverse transform to add back together all of the waves. For our ocean simulation we can define a spectrum that is obtained from real oceanographic data, and use the inverse transform to generate a surface height map.

However, let's take a moment to consider how this is different than what we did before. Both approaches sum together a variety of waves, but the spectrum for the sum of sines was generated using fractal brownian motion. So why do we need the Fourier transform? The answer lies in the time complexity of the algorithm. 

Consider that as the size of our ocean grows (to be convincing, it needs to), the shader must add up waves for every point displaced. If the ocean is $n$ x $n$ vertices, the number of calculations is proportional to $n^2$. Therefore, we consider the algorithm $O(n^2)$, pronounced $O$ of $n^2$. As we scale our ocean, the number of computations grows too fast to be reasonable. Here's where the Fourier transform comes in: *Using symmetry revealed by waves in the complex plane, the Fourier transform's time complexity can be reduced!* What a mouthful!

## More on the Fourier Transform

After careful consideration, I've decided not to attempt to derive the fast Fourier transform in this post (FFT). The algorithm is difficult to intuitively arrive at. While I had written a section about it, I 


The DFT at first glance also has an implementation that is $O(n^2)$, so how can we exploit symmetry? It's not very intuitive to visualize, so we're going to expand the DFT to search for a pattern. Remember that in the DFT, $X(k)$ represents the frequency-domain, and $x(n)$ represents the time-domain Here is the formula for the transform:

$$ x(n) = \sum^{N-1}_{k=0} X(k) e^{2\pi i kn/N}$$

The easiest way to understand this origin is to expand this equation into a term-wise sum, grouping terms with and even power of $\omega$ together, and leaving the rest together.

Let's expand this into a grid that represents the sums in the DFT. We'll list out each term, and since we have four signals, we'll have four sums of four amplitudes, giving us a grid of $16$ terms to add. To make the notation more convenient, we'll use $\omega$ to represent the $4$-th root of unity (which is just $i$).

$$\begin{matrix} x(0) = X(0)\omega^{0(0)} + X(1)\omega^{1(0)} + X(2)\omega^{2(0)} + X(3)\omega^{3(0)} \\ \\
                 x(1) = X(0)\omega^{0(1)} + X(1)\omega^{1(1)} + X(2)\omega^{2(1)} + X(3)\omega^{3(1)} \\ \\
                 x(2) = X(0)\omega^{0(2)} + X(1)\omega^{1(2)} + X(2)\omega^{2(2)} + X(3)\omega^{3(2)} \\ \\
                 x(3) = X(0)\omega^{0(3)} + X(1)\omega^{1(3)} + X(2)\omega^{2(3)} + X(3)\omega^{3(3)} \\ \\
                 \end{matrix}$$

In all fairness, that didn't really help. Maybe that's why this algorithm is so highly regarded. Bear with me. We're going to rearrange the terms to pair the odd terms, and the even terms. Then we'll factor $\omega$ from the odd terms. The calculation is still identical at this stage.

$$\begin{matrix} x(0) = X(0)\omega^{0(0)} + X(2)\omega^{2(0)} + (X(1)\omega^{0(0)} + X(3)\omega^{1(0)})\omega^{1(0)} \\ \\
                 x(1) = X(0)\omega^{0(1)} + X(2)\omega^{2(1)} + (X(1)\omega^{0(1)} + X(3)\omega^{1(1)})\omega^{1(1)}  \\ \\
                 x(2) = X(0)\omega^{0(2)} + X(2)\omega^{2(2)} + (X(1)\omega^{0(2)} + X(3)\omega^{1(2)})\omega^{1(2)} \\ \\
                 x(3) = X(0)\omega^{0(3)} + X(2)\omega^{2(3)} + (X(1)\omega^{0(3)} + X(3)\omega^{1(3)})\omega^{1(3)} \\ \\
                 \end{matrix}$$

Here is where the magic happens. Since our waves are based on powers of the fourth roots of unity ($i$, $-1$, $-i$, $1$), we can treat $\omega^2$ as $-1$, because that's exactly what it is! Let's change the sign of addition between the evens and the odds in the table for the latrer half of the terms by factoring out $\omega^2$.

$$\begin{matrix} x(0) = X(0)\omega^{0(0)} + X(2)\omega^{2(0)} + (X(1)\omega^{0(0)} + X(3)\omega^{1(0)})\omega^{1(0)} \\ \\
                 x(1) = X(0)\omega^{0(1)} + X(2)\omega^{2(1)} + (X(1)\omega^{0(1)} + X(3)\omega^{1(1)})\omega^{1(1)}  \\ \\
                 x(2) = X(0)\omega^{0(2)} + X(2)\omega^{2(2)} - (X(1)\omega^{0(2)} + X(3)\omega^{1(2)})\omega^{1(0)} \\ \\
                 x(3) = X(0)\omega^{0(3)} + X(2)\omega^{2(3)} - (X(1)\omega^{0(3)} + X(3)\omega^{1(3)})\omega^{1(1)} \\ \\
                 \end{matrix}$$

